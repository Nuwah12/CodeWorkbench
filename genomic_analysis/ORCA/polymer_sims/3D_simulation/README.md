## 3D (Mol. Dynamics) simulation
This is the 3D portion of the loop extrusion simulation. Recorded LEF positions at each timestep are used to track progression and movement of the LEF with respect to its polymer positions. Simulation code is housed in the Jupyter notebook in the current directory (`3D_polychrom_simulation.ipynb`). \
\
Parameters for this portion of the simulation can be set in the second cell of the notebook (`Define parameters for 3D portion`):
* `N`, `LEFNum`, `LEFpositions`, and `Nframes` are all parameters that have already been set or calculated from the 1D portion of the simulation
* `steps`: The number of molecular dynamics steps (i.e. updated monomer positions) to do for every 'block'. MD simulations work on very small time intervals, so it is desirable to run many steps to obtain a changed structure.
* `box`: Dimensions of the bounding box that entraps your polymer (can be set to `False` for no PBC).
* `data`: the initial conformations of our polymers, generated by a random walk.
* `smcBondWiddleDist`: The distance, in nanometers, used to calculate the force constant acting on 2 bonded monomers ($\frac{1}{d^2}$).
* `smcBondDist`: The distance, in nanometers, of the bond between 2 bonded monomers.
* `saveEveryBlocks`: Only write coordinates of conformations (in `.h5` format) every this many blocks.
* `restartSimulationEveryBlocks`: Restart the simulation every this many blocks, with the same parameters as already defined.
#### Bond Identification
As described in the 1D simulation portion, extrusion is measured by the movement of an extruder along a polymer. At each timestep, this extruder is contacting two monomers within the polymer. These two monomers are considered **bonded**, and thus have the "active" bonded parameters set. Monomers that are bonded may or may not also be affected by nonbonding forces (`except_bonds` parameter). All other monomers are given the "inactive" parameters.
#### Adding forces
The forces added to our simulation are packaged into a `forcekit` (polychrom) describing a polymer chain. The forcekit contains 3 forces - the bonded force (Harmonic Bonds), angle force, and nonbonded force. 
* **Bonded force** (`forces.harmonic_bonds`, `openmm.HarmonicBondForce`) 
  * **k** (double) - harmonic force constant of the bond in $kJ/mol/nm^2$ 
  * **length** (double) - equilibrium length of the bond in nm
  \
These are the parameter values that are varied for 'active' and 'inactive' bonds. For *active* bonds: \
  `k = (2 * self.kT / self.conlen**2) / (simtk.unit.kilojoule_per_mole / simtk.unit.nanometer**2) * 1/bondWiggleDistance**2` \
  `length = bondDistance * length_scale` \
And for *inactive* bonds: \
  `k = 0` \
  `length = bondDistance * length_scale`

* **Angle force** describes interactions between triplets of monomers
  * **k** (float) - stiffness of the bond
  * **$\theta_0$** (float) - equilibrium angle of the bond \
  The energy of the bond at angle $\theta$ is described by a custom function, defined here as `kT * k * (theta - theta_0) * (theta - theta_0) * 0.5`

* **Nonbonded force** describes the interactions of monomers that are not regarded to be participating in a bond. It is defined by the module `forces.polynomial_repulsive` (polychrom wrapper) which wraps `openmm.CustomNonbondedForce` \
  * `trunc` (float) - energy value at dist=0
  * The repulsion energy is described by the algerbraic expression:
    ```
        rsc12 * (rsc2 - 1.0) * (trunc * kT) / emin12 + (trunc * kT);
        rsc12 = rsc4 * rsc4 * rsc4;
        rsc4 = rsc2 * rsc2;
        rsc2 = rsc * rsc;
        rsc = r / radius * rmin12;
    ```
### Energy Minimization
Before each simulation initialization, the initial (random) polymer conformation undergoes energy minimization. For a good introduction, I recommend [this paper](https://dasher.wustl.edu/chem430/readings/leach-minimization.pdf)
### Visualizing conformations
This is the workflow I use to go from simulation outputs (conformations) to an NxN aggregate matrix showing contact frequency.
1. Run a simulation. This will output as many 'blocks' as the number of simulation initializations you did in `.h5` format times the number of times you save conformations in each smulation run.
2. Use `python3 trajectory_to_txt.py <total number of confs> <path to h5> <matrix our DIR>` to dump `.h5` files to text, where the total number of conformations is the total number of 'blocks' saved by your simulation.
3. Run `python3 make_contactMaps <dir of confs> <matrix out file>` to obtain the aggregate matrix, where the specified input directory holds the previously created text files. Plot with your favorite plotting library.
